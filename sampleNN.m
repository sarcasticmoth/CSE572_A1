function [Y,Xf,Af] = myNeuralNetworkFunction(X,~,~)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Auto-generated by MATLAB, 24-Apr-2019 21:41:14.
%
% [Y] = myNeuralNetworkFunction(X,~,~) takes these arguments:
%
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = 2xQ matrix, input #1 at timestep ts.
%
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = 4xQ matrix, output #1 at timestep ts.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.392732717567874;-0.389840038768807];
x1_step1.gain = [1.11602140113636;1.12719358184917];
x1_step1.ymin = -1;

% Layer 1
b1 = [-3.4413588048609864423;-2.072528444511446466;2.1381693049439549625;-0.035696604867120222682;0.024255988592511854712;0.4159340816076205205;1.6202591290824941428;2.1850898639262394951;-3.9838105881226963945;4.3414026923766924071];
IW1_1 = [4.2192846567789557 2.9180431639067005989;3.7078304147012062231 -4.064629064190937946;-3.5665077016727457782 -4.2492228562966944949;-6.3440803900726523423 -0.020099909517896190347;-0.13378364318406746336 5.9162059092642467206;1.0341247597089044952 -4.3823509780539833258;4.2196836126507060172 2.8431107413779179716;3.9505631206904379127 -3.7778388394905237924;-2.5996107145934836957 3.0053226779400770141;2.6242827129590020618 -3.642824888539779149];

% Layer 2
b2 = [-0.53450396010954248638;0.33883058140353211618;-0.7361051691891784543;0.14653624480077453995];
LW2_1 = [0.15664543520176316127 -1.4022914790269198626 0.71276365320629064826 3.7419777065958603757 -3.1907824616500146675 1.7027468716450302466 -3.5085041720168526069 1.3827774633234610757 0.15698752996785556024 -0.64898984682700677773;-0.30242721829741697759 -1.1886692386988189085 1.6670610722121295133 2.9448594168497761459 3.1167811606798623281 -2.3370888743810516175 0.90443039634464461596 -4.2954481407315476815 0.1005205695424953305 -0.68586032974618293956;0.59826114507306915602 2.3281044734797116114 2.1179383850307864634 -3.7958883712646591668 -2.6706948012142297522 2.0434760908731419704 2.6068885833801882512 0.1173107431224096886 0.18829121151919556154 -0.73630048679047066518;1.6579775421485087872 -1.5518592908037864841 -4.1921446509510458256 -3.4370957570224396349 3.2883394222019139974 -0.73309332394914616948 0.9155788144719898547 1.6748983169672748694 -0.2415369217634679988 0.68213378891874043575];

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
    X = {X};
end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},2); % samples/series
else
    Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS
    
    % Input 1
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = softmax_apply(repmat(b2,1,Q) + LW2_1*a1);
    
    % Output 1
    Y{1,ts} = a2;
end

% Final Delay States
Xf = cell(1,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
    Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Competitive Soft Transfer Function
function a = softmax_apply(n,~)
if isa(n,'gpuArray')
    a = iSoftmaxApplyGPU(n);
else
    a = iSoftmaxApplyCPU(n);
end
end
function a = iSoftmaxApplyCPU(n)
nmax = max(n,[],1);
n = bsxfun(@minus,n,nmax);
numerator = exp(n);
denominator = sum(numerator,1);
denominator(denominator == 0) = 1;
a = bsxfun(@rdivide,numerator,denominator);
end
function a = iSoftmaxApplyGPU(n)
nmax = max(n,[],1);
numerator = arrayfun(@iSoftmaxApplyGPUHelper1,n,nmax);
denominator = sum(numerator,1);
a = arrayfun(@iSoftmaxApplyGPUHelper2,numerator,denominator);
end
function numerator = iSoftmaxApplyGPUHelper1(n,nmax)
numerator = exp(n - nmax);
end
function a = iSoftmaxApplyGPUHelper2(numerator,denominator)
if (denominator == 0)
    a = numerator;
else
    a = numerator ./ denominator;
end
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end
